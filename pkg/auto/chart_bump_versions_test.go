package auto

import (
	"testing"

	"github.com/blang/semver"
	"github.com/rancher/charts-build-scripts/pkg/charts"
	"github.com/rancher/charts-build-scripts/pkg/lifecycle"
	"github.com/stretchr/testify/assert"
)

func Test_parseRepoPrefixVersionIfAny(t *testing.T) {

	versionWithRepoPrefix := "105.0.0+up1.0.0"
	versionWithoutRepoPrefix := "1.0.0"

	t.Run("version with repo prefix", func(t *testing.T) {
		repoPrefixVersion, version, found := parseRepoPrefixVersionIfAny(versionWithRepoPrefix)
		assert.Equal(t, true, found)
		assert.Equal(t, "105.0.0", repoPrefixVersion)
		assert.Equal(t, "1.0.0", version)
	})

	t.Run("version without repo prefix", func(t *testing.T) {
		repoPrefixVersion, version, found := parseRepoPrefixVersionIfAny(versionWithoutRepoPrefix)
		assert.Equal(t, false, found)
		assert.Equal(t, "", repoPrefixVersion)
		assert.Equal(t, "1.0.0", version)
	})
}

func Test_calculateNextVersion(t *testing.T) {

	type input struct {
		b *Bump
	}
	type expected struct {
		err error
		b   *Bump
	}
	type test struct {
		name     string
		input    *input
		expected *expected
	}

	versionRules := &lifecycle.VersionRules{
		Rules: map[string]lifecycle.Version{
			"2.10": {Min: "105.0.0"},
			"2.9":  {Min: "104.0.0"},
		},
		BranchVersion: "2.10",
	}

	makeSemver := func(version string) *semver.Version {
		sv := semver.MustParse(version)
		return &sv
	}

	buildExpectedVersions := func(latest, latestRepoPrefix, toRelease, toReleaseRepoPrefix string) *versions {
		vrs := &versions{
			latest:              &version{},
			latestRepoPrefix:    &version{},
			toRelease:           &version{},
			toReleaseRepoPrefix: &version{},
		}

		if latest != "" {
			vrs.latest.txt = latest
			vrs.latest.svr = makeSemver(latest)
		}
		if latestRepoPrefix != "" {
			vrs.latestRepoPrefix.txt = latestRepoPrefix
			vrs.latestRepoPrefix.svr = makeSemver(latestRepoPrefix)
		}
		if toRelease != "" {
			vrs.toRelease.txt = toRelease
			vrs.toRelease.svr = makeSemver(toRelease)
		}
		if toReleaseRepoPrefix != "" {
			vrs.toReleaseRepoPrefix.txt = toReleaseRepoPrefix
			vrs.toReleaseRepoPrefix.svr = makeSemver(toReleaseRepoPrefix)
		}

		return vrs
	}

	buildInputBump := func(latestVersion string, toReleaseVersion string) *Bump {
		var toReleaseVersionPtr = &toReleaseVersion

		return &Bump{
			targetChart: "rancher-chart",
			releaseYaml: &Release{Chart: "rancher-chart"},
			Pkg: &charts.Package{
				Name:  "rancher-chart",
				Chart: charts.Chart{UpstreamChartVersion: toReleaseVersionPtr},
			},
			versionRules:      versionRules,
			assetsVersionsMap: map[string][]lifecycle.Asset{"rancher-chart": {{Version: latestVersion}}},
		}
	}

	buildExpectedBump := func(latest, latestRepoPrefix, toRelease, toReleaseRepoPrefix string) *Bump {
		var (
			toReleaseVersionPtr = &toRelease
			targetVersion       string
			targetSemver        semver.Version
		)

		if toReleaseRepoPrefix != "" {
			targetVersion = toReleaseRepoPrefix + "+up" + toRelease
			targetSemver = semver.MustParse(targetVersion)
		}

		return &Bump{
			targetChart: "rancher-chart",
			releaseYaml: &Release{Chart: "rancher-chart", ChartVersion: targetVersion},
			Pkg: &charts.Package{
				Name:                     "rancher-chart",
				Chart:                    charts.Chart{UpstreamChartVersion: toReleaseVersionPtr},
				AutoGeneratedBumpVersion: &targetSemver,
			},
			versions:          buildExpectedVersions(latest, latestRepoPrefix, toRelease, toReleaseRepoPrefix),
			versionRules:      versionRules,
			assetsVersionsMap: map[string][]lifecycle.Asset{"rancher-chart": {{Version: latest}}},
		}
	}

	tests := []test{
		{
			// success cases
			name: "#1 - must succeed",
			input: &input{
				// latest / toRelease
				b: buildInputBump("1.0.0", "2.0.0"),
			},
			expected: &expected{
				err: nil,
				// latest / latestRepoPrefix / toRelease / toReleaseRepoPrefix
				b: buildExpectedBump("1.0.0", "", "2.0.0", "105.0.0"),
			},
		},
		{
			name: "#2 - must succeed",
			input: &input{
				// latest / toRelease
				b: buildInputBump("104.9.9+up1.0.0", "2.0.0"),
			},
			expected: &expected{
				err: nil,
				// latest / latestRepoPrefix / toRelease / toReleaseRepoPrefix
				b: buildExpectedBump("1.0.0", "104.9.9", "2.0.0", "105.0.0"),
			},
		},
		{
			name: "#3 - must succeed",
			input: &input{
				// latest / toRelease
				b: buildInputBump("105.0.0+up1.0.0", "2.0.0"),
			},
			expected: &expected{
				err: nil,
				// latest / latestRepoPrefix / toRelease / toReleaseRepoPrefix
				b: buildExpectedBump("1.0.0", "105.0.0", "2.0.0", "105.1.0"),
			},
		},
		{
			name: "#4 - must succeed",
			input: &input{
				// latest / toRelease
				b: buildInputBump("105.0.0+up1.0.0", "1.1.0"),
			},
			expected: &expected{
				err: nil,
				// latest / latestRepoPrefix / toRelease / toReleaseRepoPrefix
				b: buildExpectedBump("1.0.0", "105.0.0", "1.1.0", "105.1.0"),
			},
		},
		{
			name: "#5 - must succeed",
			input: &input{
				// latest / toRelease
				b: buildInputBump("105.0.0+up1.0.0", "1.0.1"),
			},
			expected: &expected{
				err: nil,
				// latest / latestRepoPrefix / toRelease / toReleaseRepoPrefix
				b: buildExpectedBump("1.0.0", "105.0.0", "1.0.1", "105.0.1"),
			},
		},
		{
			name: "#6 - must succeed",
			input: &input{
				// latest / toRelease
				b: buildInputBump("105.1.2+up1.1.1", "1.1.4"),
			},
			expected: &expected{
				err: nil,
				// latest / latestRepoPrefix / toRelease / toReleaseRepoPrefix
				b: buildExpectedBump("1.1.1", "105.1.2", "1.1.4", "105.1.3"),
			},
		},
		{
			name: "#7 - must succeed",
			input: &input{
				// latest / toRelease
				b: buildInputBump("105.1.2+up1.1.1", "1.2.4"),
			},
			expected: &expected{
				err: nil,
				// latest / latestRepoPrefix / toRelease / toReleaseRepoPrefix
				b: buildExpectedBump("1.1.1", "105.1.2", "1.2.4", "105.2.0"),
			},
		},
		{
			name: "#8 - must succeed",
			input: &input{
				// latest / toRelease
				b: buildInputBump("105.1.2+up1.1.1", "2.2.4"),
			},
			expected: &expected{
				err: nil,
				// latest / latestRepoPrefix / toRelease / toReleaseRepoPrefix
				b: buildExpectedBump("1.1.1", "105.1.2", "2.2.4", "105.2.0"),
			},
		},
		{
			name: "#9 - must succeed",
			input: &input{
				// latest / toRelease
				b: buildInputBump("105.1.2+up1.1.1", "2.1.1"),
			},
			expected: &expected{
				err: nil,
				// latest / latestRepoPrefix / toRelease / toReleaseRepoPrefix
				b: buildExpectedBump("1.1.1", "105.1.2", "2.1.1", "105.2.0"),
			},
		},
		{
			name: "#10 - must succeed",
			input: &input{
				// latest / toRelease
				b: buildInputBump("105.1.2+up1.1.1", "1.2.0"),
			},
			expected: &expected{
				err: nil,
				// latest / latestRepoPrefix / toRelease / toReleaseRepoPrefix
				b: buildExpectedBump("1.1.1", "105.1.2", "1.2.0", "105.2.0"),
			},
		},

		{
			name: "#11 - must succeed",
			input: &input{
				// latest / toRelease
				b: buildInputBump("105.1.2+up1.1.1-rc.2", "1.1.1-rc.2"),
			},
			expected: &expected{
				err: nil,
				// latest / latestRepoPrefix / toRelease / toReleaseRepoPrefix
				b: buildExpectedBump("1.1.1-rc.2", "105.1.2", "1.1.1-rc.2", "105.1.2"),
			},
		},

		{
			name: "#12 - must succeed",
			input: &input{
				// latest / toRelease
				b: buildInputBump("105.1.2+up1.1.1-rc.2", "1.1.1-rc.3"),
			},
			expected: &expected{
				err: nil,
				// latest / latestRepoPrefix / toRelease / toReleaseRepoPrefix
				b: buildExpectedBump("1.1.1-rc.2", "105.1.2", "1.1.1-rc.3", "105.1.2"),
			},
		},
		// failure cases
		{
			name: "#1 - must fail",
			input: &input{
				// latest / toRelease
				b: buildInputBump("", "2.0.0"),
			},
			expected: &expected{
				err: errChartLatestVersion,
			},
		},
		{
			name: "#2 - must fail",
			input: &input{
				// latest / toRelease
				b: buildInputBump("105.0.0+up1.0.0", ""),
			},
			expected: &expected{
				err: errChartUpstreamVersion,
			},
		},
		{
			name: "#3 - must fail",
			input: &input{
				// latest / toRelease
				b: buildInputBump("105.0.0+up1.0.0", "105.1.1+up2.0.0"),
			},
			expected: &expected{
				err: errChartUpstreamVersionWrong,
			},
		},
		{
			name: "#4 - must fail",
			input: &input{
				// latest / toRelease
				b: buildInputBump("105.0.0+up2.0.0", "1.0.0"),
			},
			expected: &expected{
				err: errBumpVersion,
			},
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			err := tc.input.b.calculateNextVersion()
			assertError(t, err, tc.expected.err)
			if tc.expected.err == nil {
				assert.Equal(t, tc.expected.b.releaseYaml.ChartVersion, tc.input.b.releaseYaml.ChartVersion)
				assert.Equal(t, tc.expected.b.Pkg.AutoGeneratedBumpVersion, tc.input.b.Pkg.AutoGeneratedBumpVersion)

				assert.Equal(t, tc.expected.b.versions.latest.txt, tc.input.b.versions.latest.txt)
				assert.Equal(t, tc.expected.b.versions.latest.svr, tc.input.b.versions.latest.svr)

				assert.Equal(t, tc.expected.b.versions.latestRepoPrefix.txt, tc.input.b.versions.latestRepoPrefix.txt)
				assert.Equal(t, tc.expected.b.versions.latestRepoPrefix.svr, tc.input.b.versions.latestRepoPrefix.svr)

				assert.Equal(t, tc.expected.b.versions.toRelease.txt, tc.input.b.versions.toRelease.txt)
				assert.Equal(t, tc.expected.b.versions.toRelease.svr, tc.input.b.versions.toRelease.svr)

				assert.Equal(t, tc.expected.b.versions.toReleaseRepoPrefix.txt, tc.input.b.versions.toReleaseRepoPrefix.txt)
				assert.Equal(t, tc.expected.b.versions.toReleaseRepoPrefix.svr, tc.input.b.versions.toReleaseRepoPrefix.svr)
			}
		})
	}
}
