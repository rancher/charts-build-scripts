package auto

import (
	"context"
	"errors"
	"log/slog"
	"regexp"
	"strconv"
	"strings"

	"github.com/blang/semver"
	"github.com/rancher/charts-build-scripts/pkg/lifecycle"
	"github.com/rancher/charts-build-scripts/pkg/logger"
)

// versions holds all the version components required to calculte the next chart version.
// It distinguishes between the application's version (from upstream)
// and the repository-specific prefix
type versions struct {
	latest              *version // the most recent non-RC application version found in the repository
	latestRepoPrefix    *version // the most recent non-RC repository-specific (charts repository)
	toRelease           *version // new calculated application version
	toReleaseRepoPrefix *version // new calculated repository-specific version
	currentRCs          []rc     // list of existing RC versions
}

// rc Release Candidate, composed of a repository prefix and an application version.
type rc struct {
	repoPrefix *version
	appVersion *version
}

// version encapsulates a version string and its parsed semantic version representation.
type version struct {
	txt string
	svr *semver.Version
}

// updateSemver is a helper to transform a string version in its semver object representation.
func (v *version) updateSemver() error {
	newSemver, err := semver.Make(v.txt)
	if err != nil {
		return err
	}
	v.svr = &newSemver
	return nil
}

// updateTxt is a helper to transform a semver object into its string form.
func (v *version) updateTxt() {
	v.txt = v.svr.String()
}

// calculateNextVersion will calculate the next version to bump based on the latest version
// if the chart had a patch bump, it will increment the patch version for the repoPrefixVersion
// if the chart had a minor or major bump, it will increment the minor version for the repoPrefixVersion
// the major repoPrefixVersion is only bumped when Rancher version is bumped.
func (b *Bump) calculateNextVersion(ctx context.Context, versionOverride string, newChart bool) error {
	logger.Log(ctx, slog.LevelInfo, "calculate next version")
	var targetVersion string
	var targetSemver semver.Version

	if !IsRancherChartVersion(versionOverride) {
		if newChart {
			if err := b.netNewVersion(); err != nil {
				return err
			}
		} else {
			// load versions and parse the repository prefix versions from them
			if err := b.loadVersions(); err != nil {
				return err
			}

			// check and parse the versions before building the new version
			if err := b.applyVersionRules(versionOverride); err != nil {
				return err
			}

			logger.Log(ctx, slog.LevelInfo, "checking current RC's")
			currentRCs, err := getCurrentRCsFromIndex(b.assetsVersionsMap[b.target.main], b.versions.toReleaseRepoPrefix.txt)
			if err != nil {
				logger.Log(ctx, slog.LevelError, "failed checking RC's", logger.Err(err), slog.String("version", b.target.main))
				return err
			}
			if currentRCs != nil && len(currentRCs) > 0 {
				b.versions.currentRCs = currentRCs
				logger.Log(ctx, slog.LevelWarn, "RCs present", slog.Any("amount", len(currentRCs)))
				for _, rc := range currentRCs {
					rcVersion := rc.repoPrefix.txt + "+up" + rc.appVersion.txt
					logger.Log(ctx, slog.LevelDebug, "", slog.String("version", rcVersion))
				}
			}

			logger.Log(ctx, slog.LevelDebug, "", slog.String("latestVersion", b.versions.latest.txt))
			logger.Log(ctx, slog.LevelDebug, "", slog.String("latestRepoVersion", b.versions.latestRepoPrefix.txt))

			targetVersion = b.versions.toReleaseRepoPrefix.txt + "+up" + b.versions.toRelease.txt
			targetSemver = semver.MustParse(targetVersion)

			logger.Log(ctx, slog.LevelDebug, "", slog.String("toReleaseVersion", b.versions.toRelease.txt))
			logger.Log(ctx, slog.LevelDebug, "", slog.String("toReleaseRepoVersion", b.versions.toReleaseRepoPrefix.txt))
		}
	} else {
		targetVersion = versionOverride
		targetSemver = semver.MustParse(targetVersion)
	}

	// build: toRelease full version

	b.releaseYaml.ChartVersion = targetVersion
	b.Pkg.AutoGeneratedBumpVersion = &targetSemver

	logger.Log(ctx, slog.LevelInfo, "calculated bump", slog.String("version", b.Pkg.AutoGeneratedBumpVersion.String()))
	return nil
}

func IsRancherChartVersion(s string) bool {
	// Pattern explanation:
	// ^\d+\.\d+\.\d+     - Rancher version (e.g., 107.0.2)
	// \+up               - Literal "+up" separator
	// \d+\.\d+\.\d+$     - Upstream version (e.g., 0.13.2)
	pattern := `^\d+\.\d+\.\d+\+up\d+\.\d+\.\d+$`
	matched, _ := regexp.MatchString(pattern, s)
	return matched
}

// netNewVersion will calculate the first version for a previous non-existing chart
func (b *Bump) netNewVersion() error {
	b.versions = &versions{
		toRelease:           &version{},
		toReleaseRepoPrefix: &version{},
	}

	b.versions.toRelease.txt = b.Pkg.Chart.GetUpstreamVersion()
	if b.versions.toRelease.txt == "" {
		return errChartUpstreamVersion
	}
	if err := b.versions.toRelease.updateSemver(); err != nil {
		return err
	}

	b.versions.toReleaseRepoPrefix.txt = strconv.Itoa(b.versionRules.MaxVersion-1) + ".0.0"
	if err := b.versions.toReleaseRepoPrefix.updateSemver(); err != nil {
		return err
	}

	return nil
}

// loadVersions will load the latest version from the index.yaml and the version to release from the chart owner upstream repository
// rules:
//   - latest version might not contain a repoPrefixVersion
//   - to release version must not contain a repoPrefixVersion
func (b *Bump) loadVersions() error {
	b.versions = &versions{
		latest:              &version{},
		latestRepoPrefix:    &version{},
		toRelease:           &version{},
		toReleaseRepoPrefix: &version{},
		currentRCs:          make([]rc, 0),
	}

	// Latest version might contain a repoPrefixVersion
	latestRepoPrefix, latestVersion, found, err := getLatestVersionFromIndex(b.assetsVersionsMap[b.target.main])
	if err != nil {
		return err
	}

	// there is still one chart that only has the repo-prefix version like 105.0.0
	// and does not have an app version.
	if found {
		b.versions.latestRepoPrefix.txt = latestRepoPrefix
		if err := b.versions.latestRepoPrefix.updateSemver(); err != nil {
			return err
		}
	}

	b.versions.latest.txt = latestVersion
	if err := b.versions.latest.updateSemver(); err != nil {
		return err
	}

	// toRelease version comes from the chart owner upstream repository
	b.versions.toRelease.txt = b.Pkg.Chart.GetUpstreamVersion()
	if b.versions.toRelease.txt == "" {
		return errChartUpstreamVersion
	}
	if err := b.versions.toRelease.updateSemver(); err != nil {
		return err
	}

	// upstream/(to release version) must not contain a repoPrefixVersion
	if _, _, found := parseRepoPrefixVersionIfAny(b.versions.toRelease.txt); found {
		return errChartUpstreamVersionWrong
	}

	// Check if latestVersion > versionToRelease before continuing
	if b.versions.toRelease.svr.LT(*b.versions.latest.svr) {
		return errBumpVersion
	}

	return nil
}

// getLatestVersionFromIndex will get the latest version written in the index.yaml
// that is not a RC (Release Candidate).
func getLatestVersionFromIndex(versions []lifecycle.Asset) (string, string, bool, error) {
	// get the latest released version from the index.yaml (the first version is the latest; already sorted)
	// but it may be a Release Candidate, so getLatestVersionRecursively will filter that out.
	latestUnparsedVersion := getLatestVersionRecursively(versions)
	if latestUnparsedVersion == "" {
		return "", "", false, errChartLatestVersion
	}

	latestRepoPrefix, latestVersion, found := parseRepoPrefixVersionIfAny(latestUnparsedVersion)
	return latestRepoPrefix, latestVersion, found, nil
}

// getLatestVersionRecursively will get the latest non-RC version from the entry at the index.yaml
func getLatestVersionRecursively(versions []lifecycle.Asset) string {
	latestVersion := versions[0].Version
	if strings.Contains(latestVersion, "-rc") {
		return getLatestVersionRecursively(versions[1:])
	}

	return latestVersion
}

// getCurrentRCsFromIndex will get the corresponding release candidate versions of the chart version being bumped
func getCurrentRCsFromIndex(versions []lifecycle.Asset, toReleasePrefix string) ([]rc, error) {
	if !strings.Contains(versions[0].Version, toReleasePrefix) || toReleasePrefix == "" {
		return nil, nil
	}

	currentRCs := make([]rc, 0)
	for _, v := range versions {
		if !strings.Contains(v.Version, toReleasePrefix) {
			break
		}

		currentRC := rc{
			repoPrefix: &version{},
			appVersion: &version{},
		}

		prefix, app, found := parseRepoPrefixVersionIfAny(v.Version)
		if !found {
			return nil, errors.New("chat version should have a repo prefix")
		}

		currentRC.repoPrefix.txt = prefix
		currentRC.repoPrefix.updateSemver()
		currentRC.appVersion.txt = app
		currentRC.appVersion.updateSemver()

		currentRCs = append(currentRCs, currentRC)
	}

	return currentRCs, nil
}

// parseRepoPrefixVersionIfAny will parse the repository prefix version if it exists
func parseRepoPrefixVersionIfAny(unparsedVersion string) (repoPrefix, version string, found bool) {
	found = strings.Contains(unparsedVersion, "+up")
	if found {
		versions := strings.Split(unparsedVersion, "+up")
		repoPrefix = versions[0]
		version = versions[1]
	} else {
		version = unparsedVersion
	}

	return repoPrefix, version, found
}

// applyVersionRules determines the correct repository-specific version prefix for the upcoming release.
// It considers several factors:
//   - branch's versioning rules (a new branch will reset the prefix to: 10x.0.0)
//   - semantic difference between the latest released version and the new upstream version.
//   - optional manual override for the version.
//     It will calculate automatically patch or minor increments.
func (b *Bump) applyVersionRules(versionOverride string) error {

	// get the repository major prefix version rule (i.e., 105; 104; 103...)
	repoPrefixVersionRule := b.versionRules.Rules[b.versionRules.BranchVersion].Min
	repoPrefixSemverRule, err := semver.Make(repoPrefixVersionRule)
	if err != nil {
		return err
	}

	/** This will handle the cases:
	* 	- last version: X.Y.Z | repoPrefixVersion: 105.0.0
	*   - last version: 104.X.Y+upX.Y.Z | repoPrefixVersion: 105.0.0
	* in each case, the repoPrefixVersion will be bumped to 105.0.0
	 */
	if b.versions.latestRepoPrefix.txt == "" || repoPrefixSemverRule.Major != b.versions.latestRepoPrefix.svr.Major {
		b.versions.toReleaseRepoPrefix.txt = repoPrefixVersionRule
		if err := b.versions.toReleaseRepoPrefix.updateSemver(); err != nil {
			return err
		}
		// if we are changing branch lines the repoPrefix will always be: 10X.0.0; return now.
		return nil
	}

	b.versions.toReleaseRepoPrefix.txt = b.versions.latestRepoPrefix.txt
	if err := b.versions.toReleaseRepoPrefix.updateSemver(); err != nil {
		return err
	}

	if versionOverride == "" || versionOverride == "auto" {
		// now only calculate if it is a minor or patch bump according to the latest version.
		majorBump := b.versions.toRelease.svr.Major > b.versions.latest.svr.Major
		minorBump := b.versions.toRelease.svr.Minor > b.versions.latest.svr.Minor
		patchBump := b.versions.toRelease.svr.Patch > b.versions.latest.svr.Patch

		if patchBump && !majorBump && !minorBump {
			b.versions.toReleaseRepoPrefix.svr.Patch++ // patch bump
		}
		if minorBump || majorBump {
			b.versions.toReleaseRepoPrefix.svr.Minor++ // minor bump
			b.versions.toReleaseRepoPrefix.svr.Patch = 0
		}

	} else if versionOverride == "patch" {
		b.versions.toReleaseRepoPrefix.txt = b.versions.latestRepoPrefix.txt
		b.versions.toReleaseRepoPrefix.updateSemver()
		b.versions.toReleaseRepoPrefix.svr.Patch++
		b.versions.toReleaseRepoPrefix.svr.Minor = 0
		b.versions.toReleaseRepoPrefix.updateTxt()
	} else if versionOverride == "minor" {
		b.versions.toReleaseRepoPrefix.txt = b.versions.latestRepoPrefix.txt
		b.versions.toReleaseRepoPrefix.updateSemver()
		b.versions.toReleaseRepoPrefix.svr.Minor++
		b.versions.toReleaseRepoPrefix.svr.Patch = 0
		b.versions.toReleaseRepoPrefix.updateTxt()
	}

	b.versions.toReleaseRepoPrefix.updateTxt()
	return nil
}
